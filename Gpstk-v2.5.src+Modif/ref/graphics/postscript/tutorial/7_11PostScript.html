<html><head><!-- This document was created from RTF source by rtftohtml version
2.7.5 --></head><BODY><h2>
<a name="RTFToC1">7.11.
POSTSCRIPT
</a></h2>

<h3>
<br>
<a name="RTFToC2">7.11.1
INTRODUCTION TO POSTSCRIPT
</a></h3>
<p>
The PostScript page description language is useful for representing the printed
page in a device independent manner.  It is the language that the majority of
the laser printers in the Department of Computer Science understand.  It is
also used by some of the new window managers as their graphical language.<p>
<p>
Some features of the PostScript language are:<p>
-	PostScript is particularly suited to describe graphical information<p>
-	about 1/3 of PostScript is devoted to graphics -- the remainder is a general
purpose programming language which closely resembles FORTH and other
stack-oriented languages<p>
-	it is often called a "page generation language"<p>
-	it is interpreted<p>

<h3>
<a name="RTFToC3">7.11.2
VIEWING POSTSCRIPT FILES
</a></h3>
<p>
PostScript files can be viewed by either using some kind of viewing program or
by sending them to a PostScript printer.  To view a PostScript file on the
workstation monitor, use the <i>GhostScript</i> program.  To print your file,
use the <i>lpr</i> command.<p>

<h4>
<a name="RTFToC4">7.11.2.1
USING GHOSTSCRIPT
</a></h4>
GhostScript is a PostScript interpreter that runs on many different computers
under a variety of different environments.  It can be used as a stand alone
program or as a front/back end for other programs such as <i>ghostview</i>, for
example.  To use GhostScript, log into an terminal with X display capabilities,
such as one of the DEC Stations and enter the command <tt>'gs'</tt>.
GhostScript uses a command line window for command entry and displays results
in another X-Window.  You can enter a PostScript program interactively by
directly typing it into GhostScript, line by line, or you can load and execute
a program using the following command:  <tt>'(filename.ps) run'</tt>.  To get
out of GhostScript, type <tt>'quit'</tt>.<p>

<h4>
<a name="RTFToC5">7.11.2.2
USING LPR
</a></h4>
In most applications, a PostScript program (or PostScript file) is created and
saved automatically or sent to some output device, such as a printer.  To print
out a PostScript file, the printer used must support the PostScript language,
as is the case for all laser printers in the CS department.  To print out your
PostScript source code you should use the following command:<p>
<p>
<tt>		lpr -Pc135ps filename.ps</tt><p>
<tt></tt><p>
To print out the output from your PostScript source code you should make sure
that the first line of your program is "<tt>%!</tt>" and then issue the same
lpr command as before.  If the first line of your program is not "<tt>%!</tt>",
then the source code will be printed and not the image generated by the source
code.<p>

<h3>
<a name="RTFToC6">7.11.3
POSTSCRIPT INTERNALS
</a></h3>

<h4>
<a name="RTFToC7">7.11.3.1
POSTSCRIPT'S STACK
</a></h4>
PostScript reserves a piece of memory called a <i>stack</i> (FILO, LIFO).  All
PostScript functions (known as <i>macros</i>) which require parameters take
them from the stack.  When passing values to macros, they are placed on the
stack in the proper order required.  PostScript uses <i>postfix notation</i>.
The operands that it requires are placed on the stack in the order required and
the results of the operation are then placed on the stack after the operands
have been removed.<p>

<h4>
<a name="RTFToC8">7.11.3.2
POSTSCRIPT GRAPHICAL OBJECTS
</a></h4>
PostScript supports 3 types of graphical objects:<p>
	- <b>Text</b>:<p>
		- any typeface in any position, orientation, or scale<p>
	- <b>Geometric Figures</b>:<p>
- describe locations of lines of any size, orientation, &amp; width as well as
spaces of any size, shape, or colour<p>
	- <b>Sampled Images</b>:<p>
		- in any scale or orientation<p>

<h4>
<a name="RTFToC9">7.11.3.3
POSTSCRIPT IMAGING MODELS
</a></h4>
An <i>imaging model </i>is a set of rules which are very similar to those used
by graphical artists.  A page is built up piece by piece and then displayed on
an output device.  In PostScript, all "paint" is opaque.<p>
	- <b>current page</b>:<p>
-	this is the "ideal page" that the image is drawn on and is independent of any
output device used<p>
-	when a program begins, the current page is blank<p>
	- <b>current path</b>:<p>
-	a set of connected and disconnected points, lines, and curves that, together,
describe shapes and positions<p>
-	a path is not actually a mark on a page (yet) but must be stroked, clipped,
or filled<p>
	- <b>clipping path</b>:<p>
-	the boundary of the area that may be drawn upon -- originally the standard
paper size but can be any size or shape<p>

<h4>
<a name="RTFToC10">7.11.3.4
COORDINATE SYSTEM
</a></h4>
PostScript uses a standard X,Y coordinate system with location (0,0) in the
bottom left hand corner.  This is known as <i>user space</i>.  Different output
devices have different, idiosyncratic coordinate systems, which is called
<i>device space</i>.  Coordinates in a PostScript program are automatically
transformed from user space to device space before actual printing of the
current page.  User space may be altered by <i>translating</i>,
<i>rotating</i>, or <i>scaling </i>PostScript's default units are 1/72 inch,
also known as a <i>point</i>.  Therefore, 72 points is equal to one inch.<p>

<h3>
<a name="RTFToC11">7.11.4
EXAMPLES
</a></h3>

<h4>
<a name="RTFToC12">7.11.4.1
SIMPLE EXAMPLES
</a></h4>
The following are short examples that demonstrate the use of the PostScript
stack.<p>
<pre>
<p>
- to add 2 numbers together:<p>
<tt>5 27 <b>add</b></tt>		stack: 	5	27<p>
			stack:	32<p>
<p>
- to subtract 2 numbers:<p>
<tt>8.3 6.6 <b>sub</b></tt>	stack:	8.3	6.6<p>
			stack:	1.7<p>
- the sub operator subtracts the top number on the stack from the bottom
number<p>
<p>
- to divide 2 numbers:<p>
<tt>13 8 <b>div</b></tt>		stack:	13	8<p>
			stack:	1.625<p>
- like sub, div divides the bottom number by the top number<p>
<p>
- to perform: 6 + (3 / 8)<p>
<tt>3 8 <b>div</b> 6 <b>add</b></tt>	stack:	3	8<p>
			stack:	.375			&lt;div operation&gt;<p>
			stack:	.375	6<p>
			stack:	6.375			&lt;add operation&gt;<p>
    OR<p>
<p>
<tt>6 3 8 <b>div</b> <b>add</b></tt>	stack:	6	3	8<p>
			stack:	6	.375		&lt;div operation&gt;<p>
			stack:	6.375			&lt;add operation&gt;<p>
<p>
Some other of the most used PostScript arithmetic operators are:<p>
<tt><b>idiv</b></tt>	- divide the bottom number by the top number but only keep
the integer<p>
<tt><b>mod</b></tt>	- divide the bottom number by the top number but only keep
the remainder<p>
<tt><b>mul</b></tt>	- multiply the top two numbers of the stack<p>
<tt><b>neg</b></tt>	- reverse the sign of the number at the top of the stack<p>
<p>
Some other of the most used PostScript stack operators include:<p>
<tt><b>exch</b></tt>	- reverse the order of the top two elements of the stack<p>
<tt><b>clear</b></tt>	- removes all items from the stack<p>
<tt><b>dup</b></tt>	- duplicates the top item of the stack<p>
<tt><b>pop</b></tt>	- remove the top element from the stack<p>
</pre>

<h4>
<a name="RTFToC13">7.11.4.2
MORE COMPLEX EXAMPLES
</a></h4>
The following are some PostScript example programs selected to show the
features of PostScript in action.  As with any other language, the only way to
learn it is to try it.  In the examples below, as new PostScript keywords are
encountered, they will be highlighted.<p>
<pre>
<p>
<u>ex 1 - draw a vertical line:</u><p>
<u></u>This routine draws a simple vertical line.<p>
<u></u><p>
<u></u><tt><b>newpath</b>			% empty the current path and start a new one</tt><p>
<tt>	144 72 <b>moveto</b>		% move to a new location</tt><p>
<tt>	144 432 <b>lineto	</b>% add a segment to the current path</tt><p>
<tt><b>stroke</b>				% paint the current path</tt><p>
<tt><b>showpage</b>				% print the current page</tt><p>
<tt></tt><p>
<u>ex 2 - draw  2 intersecting lines:</u><p>
<u></u>This routine intersects a vertical line with a diagonal line.<p>
<u></u><p>
<u></u><tt>newpath</tt><p>
<tt>	72 360 moveto</tt><p>
<tt>	144 72 <b>rlineto</b>	% move using relative coordinates</tt><p>
<tt>	144 432 moveto</tt><p>
<tt>	0 -216 <b>rlineto</b></tt><p>
<tt>stroke</tt><p>
<tt>showpage</tt><p>
<tt></tt><p>
<tt></tt><u>ex 3 - draw a box:</u><p>
<u></u>The following routine draws a box with a line thickness value of 4.
Since PostScript ignores the thickness of lines when drawing, the box will not
be closed correctly.<p>
<p>
<tt>newpath</tt><p>
<tt>	270 360 moveto</tt><p>
<tt>	0 72 rlineto</tt><p>
<tt>	72 0 rlineto</tt><p>
<tt>	0 -72 rlineto</tt><p>
<tt>	-72 0 rlineto</tt><p>
<tt>	4 <b>setlinewidth</b></tt><p>
<tt>stroke</tt><p>
<tt>showpage</tt><p>
<tt></tt><p>
<tt></tt><p>
<tt></tt><p>
<tt>
<IMG SRC="7_11PostScript1.gif"></tt><p>
<tt></tt><u>ex 4 - draw a better box:</u><p>
<u></u>This routine, almost identical to the previous one, draws a better box
by using the <tt>'closepath'</tt> operator.  This causes the box to be closed
properly and automatically by PostScript itself.  Notice that the last line is
derived by PostScript as opposed to having to be specified explicilty by the
programmer.<p>
<p>
<tt>newpath</tt><p>
<tt>	270 360 moveto</tt><p>
<tt>	0 72 rlineto</tt><p>
<tt>	72 0 rlineto</tt><p>
<tt>	0 -72 rlineto</tt><p>
<tt>	<b>closepath</b></tt><p>
<tt>	4 setlinewidth</tt><p>
<tt>stroke</tt><p>
<tt>showpage	% because of the 'closepath', the square is now closed</tt><p>
<tt></tt><p>
<u>ex 5 - draw a filled box:</u><p>
<u></u>The following routine is a basic box drawing routine.  The
<tt>'fill'</tt> command is used to demonstrate how PostScript will
automatically fill in closed areas.  The command <tt>'setgray'</tt> is also
used to show how PostScript can use different shades of gray.  A value of
<b>0</b> is black and <b>1</b> is white.<p>
<p>
<tt>newpath</tt><p>
<tt>	270 360 moveto</tt><p>
<tt>	0 72 rlineto</tt><p>
<tt>	72 0 rlineto</tt><p>
<tt>	0 -72 rlineto</tt><p>
<tt>	closepath</tt><p>
<tt>	.85 <b>setgray</b>	% set gray value to light gray</tt><p>
<tt><b>fill</b>			% this fills the box</tt><p>
<tt>showpage</tt><p>
<tt></tt><p>
<u>ex 6 - variables:</u><p>
<u></u>Like most other languages, PostScript allows the program to use
variables.  In PostScript, however, variables must be defined and placed in a
<i>dictionary</i>.<p>
<p>
<tt>/ppi 72 <b>def</b></tt><p>
<tt></tt>- the / indicates that ppi is a literal and not yet in any
dictionary<p>
- the 72 is pushed onto the stack next<p>
- the <tt>def</tt> takes the 2 objects off the stack and enters them into the
current dictionary<p>
<p>
The following arithmetic expression makes use of the value stored in ppi.<p>
<tt>10 ppi <b>mul</b></tt>	stack:	10	72<p>
			stack:	720<p>
<p>
This small program uses ppi to measure the length of lines.  Recall that 72
points is equivalent to one inch.<p>
<p>
<tt>newpath	% draw a 1 inch vertical line</tt><p>
<tt>	100 100 moveto</tt><p>
<tt>	0 ppi rlineto</tt><p>
<tt>stroke</tt><p>
<tt>showpage</tt><p>
<tt></tt><p>
<u>ex 7 - a procedure:</u><p>
<u></u>The following program uses a macro, <tt>inch</tt>, to measure lines.
The code between the braces, "<tt>72 mul</tt>", is placed on the stack when the
macro itself is called.<p>
<u></u><p>
<u></u><tt>/inch  {72 mul} def</tt><p>
<tt></tt><p>
<tt>newpath	% draw a 5 inch vertical line</tt><p>
<tt>	100 100 moveto</tt><p>
<tt>	0 5 <b>inch</b> rlineto	% causes the command: 5 72 mul</tt><p>
<tt>stroke</tt><p>
<tt>showpage</tt><p>
<tt></tt><p>
<u>ex 8 - simple text:</u><p>
<u></u>PostScript can use any Type 1 font.  There are literally thousands of
fonts available for use so the best way to determine what fonts are available
on a printer or other display device is to try to print them out.<p>
<u></u><p>
<u></u><tt>/Times-Roman <b>findfont</b>	% findfont looks up font in
dictionary</tt><p>
<tt>					% "FontDirectory" and places the</tt><p>
<tt>					% appropriate dictionary on the stack</tt><p>
<tt>15 <b>scalefont</b>		% takes a font dictionary from the stack</tt><p>
<tt>				% and scales it according to the top number</tt><p>
<tt>				% on the stack</tt><p>
<tt><b>setfont</b>			% take the scaled font dictionary off the</tt><p>
<tt>				% stack and establish it as the current font</tt><p>
<tt>72 200 moveto</tt><p>
<tt>(type this) <b>show</b>	% show prints a string (...)</tt><p>
<tt>showpage</tt><p>
<tt></tt><p>
<p>
<u>ex 9 - arcs:</u><p>
The <tt>'arc'</tt> operator is used to draw any arcs and circles using 5 stack
parameters which are:<p>
-	the <b>X</b> and <b>Y</b> locations for the centre of the circle<p>
-	the <b>radius</b><p>
-	the <b>start</b> and <b>end</b> degrees (counterclockwise) of the circle for
the arc<p>
<p>
<tt>newpath	% draw an arc from 45 to 90 degrees</tt><p>
<tt>	100 150 36 45 90 <b>arc</b></tt><p>
<tt>	stroke</tt><p>
<tt>	500 400 50 0 360 <b>arc</b></tt><p>
<tt>	fill</tt><p>
<tt>showpage</tt><p>
<tt></tt><p>
</pre>

<h3>
<a name="RTFToC14">7.11.5
POSTSCRIPT IMAGES
</a></h3>
<p>
PostScript contains numerous operators that allow users to create graphics.
PostScript also contains features that allow for the easy manipulation of
<i>bitmaps</i>.  The <i>image</i> operator is used to perform these functions<p>

<h4>
<a name="RTFToC15">7.11.5.1
THE IMAGE OPERATOR
</a></h4>
The image operator interprets the bits passed to it as a description of the
gray values of a stream of pixels of from one to eight bits each.  The results
are printed in a <i>one-unit square</i> in which the lower left corner is at
the origin.  To view the image you must <i>scale</i> it to a viewable size
since the default is 1/72 inch -- far to small to be really usable.<p>
<p>
The image operator requires 5 arguments:<p>
	- <b>scan length</b><p>
-	the number of samples per scan line<p>
	- <b>scan lines</b><p>
-	the number of scan lines in the image<p>
	- <b>bits per sample</b><p>
-	the number of bits making up the sample (1, 2, 4, or 8)<p>
-	an image with 1 bit sampling will print in black or white while an image with
8 bit sampling will print using the values 0 (black) through 255 (white)<p>
	- <b>transform matrix</b><p>
-	the image operators impose a coordinate system on the source image:<p>
<IMG SRC="7_11PostScript2.gif"><p>
	where <b>w</b> is the width and <b>h</b> is the height<p>
-	other conventions (ie. user space) can be mapped into the PostScript
convention (image space) by coordinate transformations<p>
-	a six element array that determines the mapping of samples into the one unit
square imaging region<p>
-	for an image with scan length of n and scan lines of m, the following matrix
is used:  [ n 0 0 m 0 0 ]<p>
-	for an image whose data begins in the upper left corner as opposed to the
lower left (PostScript's default), the following matrix may be used:  [ n 0 0
-m 0 m ]<p>
-	for a more general definition of the transform matrix, please refer to
Section 4.4 of the PostScript Language Reference Manual<p>
	- <b>procedure</b><p>
-	this is the procedure that produces the data strings needed by <i>image</i><p>
-	if the string does not describe the complete image, the image operator will
call this procedure again and again until the number of samples implied by the
first 3 arguments have been processed<p>
-	any unused data left in the string at the end of the image is ignored as are
any bits left in the current character of data at the end of the scan line<p>

<h4>
<a name="RTFToC16">7.11.5.2
POSITION, ORIENTATION, AND SIZING
</a></h4>
An image that has been mapped into the unit square may then be placed on the
output page in the desired position, orientation, and size by invoking
operations such as translate, rotate, and scale<p>
ex:	To place an image into a rectangle where the lower left corner is at
(100,200), is rotated 45 degrees counterclockwise, and is 150 units wide and 80
high, one would execute the following prior to invoking the image operator:<p>
<p>
<tt>	100 200 <b>translate</b> 45 <b>rotate</b> 150 80 <b>scale</b></tt><p>
<tt></tt>
<h4>
<a name="RTFToC17">7.11.5.3
A BINARY IMAGE:
</a></h4>
Consider the following 16 bit string:<tt>  1100100100110110</tt><p>
<p>
We can use the preceeding string in a PostScript program, such as in the
following segment:<p>
<p>
<tt>400 400 translate	% position of lower left corner</tt><p>
<tt>72 72 scale		% make the image 1 inch by 1 inch square</tt><p>
<tt>8 8 1 [8 0 0 8 0 0] {&lt;c936&gt;} <b>image</b></tt><p>
<tt>showpage</tt><p>
<tt></tt><p>
-	The third line prints an 8 pixel by 8 line image, each pixel being 1 bit
deep.<p>
-	The transform matrix will fill the unit square with the image.<p>
-	The procedure argument encloses a hexadecimal string, denoted by the angle
brackets:<p>
-	each pair of characters represents an 8 bit code, therefore <tt>c936</tt> is
interpreted as the 16 bit string listed above<p>
-	it is important to note that, by default, PostScript defines images with the
origin in the lower left corner and where the higher numbers are lighter
colours and the lower numbers are darker colours -- in this case, 1 is white
and 0 is black<p>
<p>
The above program produces a simple bitmap where, since each line of the image
is eight one-bit samples wide, each call of the procedure will supply data for
two lines producing an image something like:<p>
<tt></tt><p>
<tt>00110110</tt><p>
<tt>11001001</tt><p>
<tt>00110110</tt><p>
<tt>11001001</tt><p>
<tt>00110110</tt><p>
<tt>11001001</tt><p>
<tt>00110110</tt><p>
<tt>11001001</tt><p>
<tt></tt><p>
By changing the bits per sample a different pattern is created -- recall that 1
bit per sample results in a black and white image, 2 bits produces shades of
gray from 0 to 3, 4 bits produces shades from 0 to 15, and 8 produces from 0 to
255<p>

<h4>
<a name="RTFToC18">7.11.5.4
CREATING AN IMAGE
</a></h4>
PostScript images can be created in a number of different ways:<p>
- <b>generated by another program</b><p>
-	many programs generate output files in PostScript format -- PMDraw, Corel
Draw, and Super Paint are some examples<p>
- <b>scanned in</b><p>
-	a user may decide to use a scanner to digitize an existing picture and store
it as a PostScript bitmap<p>
- <b>created entirely by hand</b><p>
-	a user may also decide to generate a bitmap entirely by hand, for example, by
using a pencil and some graph paper<p>
<p>
ex:	Suppose a raster image of 256 by 256, 8 bits per pixel is available -- one
way to display it is:<p>
<pre>
<p>
<tt>/picstr 256 string def	% string to hold image data</tt><p>
<tt>45 140 translate		% lower left corner of image</tt><p>
<tt>132 132 scale		% map image to 132 point scale</tt><p>
<tt>256 256 8			% dimensions of source image</tt><p>
<tt>[ 256 0 0 -256 0 256]	% map the unit square to the</tt><p>
<tt>					% source image</tt><p>
<tt>{ <b>currentfile</b>			% read image data from the</tt><p>
<tt>					% program file</tt><p>
<tt>  picstr <b>readhexstring</b> <b>pop</b></tt><p>
<tt>} image</tt><p>
<tt>4c 47 49 4b 4d 4c 52 4c 4d 50 53 ............</tt><p>
<tt>% 256 x 256 x2 hex digits of image data</tt><p>
<tt>% note: one 8-bit pixel is converted to two hex digits</tt><p>
<tt>showpage</tt><p>
<tt></tt>
</pre>
<h3>
<a name="RTFToC19">7.11.6
MISCELLANEOUS POSTSCRIPT OPERATORS
</a></h3>
In addition to the image manipulation described above, there are some others
that may be of use:<p>
	- <b>gsave</b><p>
-	save the current graphics state on a <i>graphics state stack</i>, which can
hold up to 32 states including the current one<p>
	- <b>grestore</b><p>
-	restores the most recently saved graphics state -- all the characteristics of
the state including current path, gray level, line width, and user coordinate
system are returned to what they were when gsave was executed<p>
	- <b>X Y scale</b><p>
-	set the appropriate scaling factor for all subsequent operations<p>
	- <b>currentpoint</b><p>
-	put the coordinates of the current location on the stack<p>
	- <b>n { ... } repeat</b><p>
<b></b>-	the repeat loop causes a procedure to be executed n times<p>
	- <b>l m n { ... } for</b><p>
<b></b>-	the for loop iterates a procedure from l to n by an increment (or
decrement) value of m<p>
	- <b>( ... ) stringwidth</b><p>
-	stringwidth returns the length of the string ( ... ) and (usually) the value
0.0<p>
ex:	the following code will determine the width of a string and center it on
some background that is 200 units wide<p>
<p>
<tt>(PostScript) <b>stringwidth</b> pop</tt><p>
<tt>200 exch sub 2 div</tt><p>
<tt>0 rmoveto</tt><p>
<tt>(PostScript) show</tt><p>
<tt></tt>
<h3>
<a name="RTFToC20">7.11.7
OTHER FILES OR BOOKS OF INTEREST
</a></h3>
A few sample images are stored on the U of R <b>ftp</b> site in the directory
<b>pub/405/PS</b>.  These images are contained in actual PostScript programs --
to incorporate them into your own programs, you will need to edit the images
out.  Some of the sample PostScript programs use the commands described above
as well as other commands not described in this manual, so it would be
beneficial to give them a view.<p>
<p>
Other sample files are available in <b>/net/share/lib/ghostscript/examples</b>.
To determine which fonts are available for use in GhostScript, you may want to
look in the file <b>/net/share/lib/ghostscript/Fontmap</b> for a list of the
correct font names.  The directory <b>/net/share/lib/ghostscript/doc</b> also
contains a number of very useful documentation files for GhostScript as well as
for PostScript in general.<p>
<p>
The two books "PostScript Language Tutorial and Cookbook" and "PostScript
Language Reference Manual" are very good PostScript references published by
Adobe Systems Incorporated.<p>
</body></html>
